const contracts = {
    "sender": "\/\/ SPDX-License-Identifier: Ecosystem\r\n\r\npragma solidity ^0.8.18;\r\nstruct TeleporterMessageReceipt {\r\n    uint256 receivedMessageNonce;\r\n    address relayerRewardAddress;\r\n}\r\n\r\n\/\/ Represents all of the information required for submitting a Teleporter message\r\n\/\/ to be sent to the given destination chain ID and address. Includes the fee\r\n\/\/ information for the message, the amount of gas the relayer must provide to execute\r\n\/\/ the message on the destination chain, the relayer accounts allowed to deliver the\r\n\/\/ message, and the message data itself.\r\nstruct TeleporterMessageInput {\r\n    bytes32 destinationBlockchainID;\r\n    address destinationAddress;\r\n    TeleporterFeeInfo feeInfo;\r\n    uint256 requiredGasLimit;\r\n    address[] allowedRelayerAddresses;\r\n    bytes message;\r\n}\r\n\r\n\/\/ Represents a message sent or received by an implementation of {ITeleporterMessenger}.\r\nstruct TeleporterMessage {\r\n    uint256 messageNonce;\r\n    address originSenderAddress;\r\n    bytes32 destinationBlockchainID;\r\n    address destinationAddress;\r\n    uint256 requiredGasLimit;\r\n    address[] allowedRelayerAddresses;\r\n    TeleporterMessageReceipt[] receipts;\r\n    bytes message;\r\n}\r\n\r\n\/\/ Represents the fee information associated to a given Teleporter message.\r\n\/\/ The contract address is the asset contract the fee will be paid in, and\r\n\/\/ the amount is the amount of that specified asset.\r\nstruct TeleporterFeeInfo {\r\n    address feeTokenAddress;\r\n    uint256 amount;\r\n}\r\n\r\n\/**\r\n * @dev Interface that describes functionalities for a cross-chain messenger implementing the Teleporter protcol.\r\n *\r\n * @custom:security-contact https:\/\/github.com\/ava-labs\/teleporter\/blob\/main\/SECURITY.md\r\n *\/\r\ninterface ITeleporterMessenger {\r\n    \/**\r\n     * @notice Emitted when the blockchain ID of the contract instance is initialized using the Warp precompile.\r\n     *\/\r\n    event BlockchainIDInitialized(bytes32 indexed blockchainID);\r\n\r\n    \/**\r\n     * @notice Emitted when sending a Teleporter message cross-chain.\r\n     *\/\r\n    event SendCrossChainMessage(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed destinationBlockchainID,\r\n        TeleporterMessage message,\r\n        TeleporterFeeInfo feeInfo\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when an additional fee amount is added to a Teleporter message that had previously\r\n     * been sent, but not yet delivered to the destination chain.\r\n     *\/\r\n    event AddFeeAmount(\r\n        bytes32 indexed messageID,\r\n        TeleporterFeeInfo updatedFeeInfo\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a Teleporter message is being delivered on the destination chain to an address,\r\n     * but message execution fails. Failed messages can then be retried with `retryMessageExecution`\r\n     *\/\r\n    event MessageExecutionFailed(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed sourceBlockchainID,\r\n        TeleporterMessage message\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a Teleporter message is successfully executed with the\r\n     * specified destination address and message call data. This can occur either when\r\n     * the message is initially received, or on a retry attempt.\r\n     *\r\n     * Each message received can be executed successfully at most once.\r\n     *\/\r\n    event MessageExecuted(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed sourceBlockchainID\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a TeleporterMessage is successfully received.\r\n     *\/\r\n    event ReceiveCrossChainMessage(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed sourceBlockchainID,\r\n        address indexed deliverer,\r\n        address rewardRedeemer,\r\n        TeleporterMessage message\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a receipt is marked as received on the source chain that sent the\r\n     * corresponding Teleporter message.\r\n     *\/\r\n    event ReceiptReceived(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed destinationBlockchainID,\r\n        address indexed relayerRewardAddress,\r\n        TeleporterFeeInfo feeInfo\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when an account redeems accumulated relayer rewards.\r\n     *\/\r\n    event RelayerRewardsRedeemed(\r\n        address indexed redeemer,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    \/**\r\n     * @notice Called by transactions to initiate the sending of a cross-chain message.\r\n     * @return The message ID of the newly sent message.\r\n     *\/\r\n    function sendCrossChainMessage(\r\n        TeleporterMessageInput calldata messageInput\r\n    ) external returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Called by transactions to retry the sending of a cross-chain message.\r\n     *\r\n     * @dev Retriggers the sending of a message previously emitted by sendCrossChainMessage that has not yet been acknowledged\r\n     * with a receipt from the destination chain. This may be necessary in the unlikely event that less than the required\r\n     * threshold of stake weight successfully inserted the message in their messages DB at the time of the first submission.\r\n     * The message is checked to have already been previously submitted by comparing its message hash against those kept in\r\n     * state until a receipt is received for the message.\r\n     *\/\r\n    function retrySendCrossChainMessage(\r\n        TeleporterMessage calldata message\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Adds the additional fee amount to the amount to be paid to the relayer that delivers\r\n     * the given message ID to the destination chain.\r\n     *\r\n     * @dev The fee token address must be the same asset type as the fee asset specified in the original\r\n     * call to sendCrossChainMessage. Reverts if the message doesn't exist or there is already\r\n     * receipt of delivery of the message.\r\n     *\/\r\n    function addFeeAmount(\r\n        bytes32 messageID,\r\n        address feeTokenAddress,\r\n        uint256 additionalFeeAmount\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Receives a cross-chain message, and marks the `relayerRewardAddress` for fee reward for a successful delivery.\r\n     *\r\n     * @dev The message specified by `messageIndex` must be provided at that index in the access list storage slots of the transaction,\r\n     * and is verified in the precompile predicate.\r\n     *\/\r\n    function receiveCrossChainMessage(\r\n        uint32 messageIndex,\r\n        address relayerRewardAddress\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Retries the execution of a previously delivered message by verifying the payload matches\r\n     * the hash of the payload originally delivered, and calling the destination address again.\r\n     *\r\n     * @dev Intended to be used if message excution failed on initial delivery of the Teleporter message.\r\n     * For example, this may occur if the original required gas limit was not sufficient for the message\r\n     * execution, or if the destination address did not contain a contract, but a compatible contract\r\n     * was later deployed to that address. Messages are ensured to be successfully executed at most once.\r\n     *\/\r\n    function retryMessageExecution(\r\n        bytes32 sourceBlockchainID,\r\n        TeleporterMessage calldata message\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Sends the receipts for the given `messageIDs`.\r\n     *\r\n     * @dev Sends the specified message receipts in a new message (with an empty payload) back to the source chain.\r\n     * This is intended for use in sending receipts that have not been sent in a timely manner by the standard\r\n     * receipt delivery mechanism.\r\n     * @return The message ID of the newly sent message.\r\n     *\/\r\n    function sendSpecifiedReceipts(\r\n        bytes32 sourceBlockchainID,\r\n        bytes32[] calldata messageIDs,\r\n        TeleporterFeeInfo calldata feeInfo,\r\n        address[] calldata allowedRelayerAddresses\r\n    ) external returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Sends any fee amount rewards for the given fee asset out to the caller.\r\n     *\/\r\n    function redeemRelayerRewards(address feeTokenAddress) external;\r\n\r\n    \/**\r\n     * @notice Gets the hash of a given message stored in the EVM state, if the message exists.\r\n     * @return The message hash\r\n     *\/\r\n    function getMessageHash(bytes32 messageID) external view returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Checks whether or not the given message has been received by this chain.\r\n     * @return Boolean representing if the given message has been received.\r\n     *\/\r\n    function messageReceived(bytes32 messageID) external view returns (bool);\r\n\r\n    \/**\r\n     * @notice Returns the address the relayer reward should be sent to on the source chain\r\n     * for a given message, assuming that the message has already been delivered.\r\n     * @return The relayer reward address for the given message.\r\n     *\/\r\n    function getRelayerRewardAddress(\r\n        bytes32 messageID\r\n    ) external view returns (address);\r\n\r\n    \/**\r\n     * @notice Gets the current reward amount of a given fee asset that is redeemable by the given relayer.\r\n     * @return The amount of the fee asset redeemable by the specified relayer.\r\n     *\/\r\n    function checkRelayerRewardAmount(\r\n        address relayer,\r\n        address feeTokenAddress\r\n    ) external view returns (uint256);\r\n\r\n    \/**\r\n     * @notice Gets the fee token address and amount for a given sent message.\r\n     * @return The fee token address and fee amount for a the given sent message ID.\r\n     * If the message ID is not found, zero address and amount values are returned.\r\n     *\/\r\n    function getFeeInfo(\r\n        bytes32 messageID\r\n    ) external view returns (address, uint256);\r\n\r\n    \/**\r\n     * @notice Gets the message ID that would currently be used for the next message sent from the contract\r\n     * instance to the given destination blockchain.\r\n     *\r\n     * @dev This message ID may never be used in the event that the next call to sendCrossChainMessage in a\r\n     * transaction uses a different destination blockchain. The current value as returned by this function will\r\n     * change with each successful call to sendCrossChainMessage.\r\n     * @return The specified message ID.\r\n     *\/\r\n    function getNextMessageID(\r\n        bytes32 destinationBlockchainID\r\n    ) external view returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Gets the number of receipts that are waiting to be sent to the given source chain ID.\r\n     * @return Size of the given queue.\r\n     *\/\r\n    function getReceiptQueueSize(\r\n        bytes32 sourceBlockchainID\r\n    ) external view returns (uint256);\r\n\r\n    \/**\r\n     * @notice Gets the receipt at the given index in the queue for the given source chain ID.\r\n     * @return The receipt requested.\r\n     *\/\r\n    function getReceiptAtIndex(\r\n        bytes32 sourceBlockchainID,\r\n        uint256 index\r\n    ) external view returns (TeleporterMessageReceipt memory);\r\n}\r\n\r\ncontract SenderMessage {\r\n    ITeleporterMessenger public immutable messenger =\r\n        ITeleporterMessenger(0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf);\r\n\r\n    \/**\r\n     * @dev Sends a message to another chain.\r\n     *\/\r\n    function sendMessage(\r\n        address destinationAddress,\r\n        bytes32 destinationBlockchainID,\r\n        string calldata message\r\n    ) external {\r\n        messenger.sendCrossChainMessage(\r\n            TeleporterMessageInput({\r\n                destinationBlockchainID: destinationBlockchainID,\r\n                destinationAddress: destinationAddress,\r\n                feeInfo: TeleporterFeeInfo({\r\n                    feeTokenAddress: address(0),\r\n                    amount: 0\r\n                }),\r\n                requiredGasLimit: 100000,\r\n                allowedRelayerAddresses: new address[](0),\r\n                message: abi.encode(message)\r\n            })\r\n        );\r\n    }\r\n}\r\n",
    "receiver": "\/\/ (c) 2023, Ava Labs, Inc. All rights reserved.\r\n\/\/ See the file LICENSE for licensing terms.\r\n\r\n\/\/ SPDX-License-Identifier: Ecosystem\r\n\r\npragma solidity ^0.8.18;\r\n\r\nstruct TeleporterMessageReceipt {\r\n    uint256 receivedMessageNonce;\r\n    address relayerRewardAddress;\r\n}\r\n\r\n\/\/ Represents all of the information required for submitting a Teleporter message\r\n\/\/ to be sent to the given destination chain ID and address. Includes the fee\r\n\/\/ information for the message, the amount of gas the relayer must provide to execute\r\n\/\/ the message on the destination chain, the relayer accounts allowed to deliver the\r\n\/\/ message, and the message data itself.\r\nstruct TeleporterMessageInput {\r\n    bytes32 destinationBlockchainID;\r\n    address destinationAddress;\r\n    TeleporterFeeInfo feeInfo;\r\n    uint256 requiredGasLimit;\r\n    address[] allowedRelayerAddresses;\r\n    bytes message;\r\n}\r\n\r\n\/\/ Represents a message sent or received by an implementation of {ITeleporterMessenger}.\r\nstruct TeleporterMessage {\r\n    uint256 messageNonce;\r\n    address originSenderAddress;\r\n    bytes32 destinationBlockchainID;\r\n    address destinationAddress;\r\n    uint256 requiredGasLimit;\r\n    address[] allowedRelayerAddresses;\r\n    TeleporterMessageReceipt[] receipts;\r\n    bytes message;\r\n}\r\n\r\n\/\/ Represents the fee information associated to a given Teleporter message.\r\n\/\/ The contract address is the asset contract the fee will be paid in, and\r\n\/\/ the amount is the amount of that specified asset.\r\nstruct TeleporterFeeInfo {\r\n    address feeTokenAddress;\r\n    uint256 amount;\r\n}\r\n\r\n\/**\r\n * @dev Interface that describes functionalities for a cross-chain messenger implementing the Teleporter protcol.\r\n *\r\n * @custom:security-contact https:\/\/github.com\/ava-labs\/teleporter\/blob\/main\/SECURITY.md\r\n *\/\r\ninterface ITeleporterMessenger {\r\n    \/**\r\n     * @notice Emitted when the blockchain ID of the contract instance is initialized using the Warp precompile.\r\n     *\/\r\n    event BlockchainIDInitialized(bytes32 indexed blockchainID);\r\n\r\n    \/**\r\n     * @notice Emitted when sending a Teleporter message cross-chain.\r\n     *\/\r\n    event SendCrossChainMessage(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed destinationBlockchainID,\r\n        TeleporterMessage message,\r\n        TeleporterFeeInfo feeInfo\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when an additional fee amount is added to a Teleporter message that had previously\r\n     * been sent, but not yet delivered to the destination chain.\r\n     *\/\r\n    event AddFeeAmount(\r\n        bytes32 indexed messageID,\r\n        TeleporterFeeInfo updatedFeeInfo\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a Teleporter message is being delivered on the destination chain to an address,\r\n     * but message execution fails. Failed messages can then be retried with `retryMessageExecution`\r\n     *\/\r\n    event MessageExecutionFailed(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed sourceBlockchainID,\r\n        TeleporterMessage message\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a Teleporter message is successfully executed with the\r\n     * specified destination address and message call data. This can occur either when\r\n     * the message is initially received, or on a retry attempt.\r\n     *\r\n     * Each message received can be executed successfully at most once.\r\n     *\/\r\n    event MessageExecuted(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed sourceBlockchainID\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a TeleporterMessage is successfully received.\r\n     *\/\r\n    event ReceiveCrossChainMessage(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed sourceBlockchainID,\r\n        address indexed deliverer,\r\n        address rewardRedeemer,\r\n        TeleporterMessage message\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when a receipt is marked as received on the source chain that sent the\r\n     * corresponding Teleporter message.\r\n     *\/\r\n    event ReceiptReceived(\r\n        bytes32 indexed messageID,\r\n        bytes32 indexed destinationBlockchainID,\r\n        address indexed relayerRewardAddress,\r\n        TeleporterFeeInfo feeInfo\r\n    );\r\n\r\n    \/**\r\n     * @notice Emitted when an account redeems accumulated relayer rewards.\r\n     *\/\r\n    event RelayerRewardsRedeemed(\r\n        address indexed redeemer,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    \/**\r\n     * @notice Called by transactions to initiate the sending of a cross-chain message.\r\n     * @return The message ID of the newly sent message.\r\n     *\/\r\n    function sendCrossChainMessage(\r\n        TeleporterMessageInput calldata messageInput\r\n    ) external returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Called by transactions to retry the sending of a cross-chain message.\r\n     *\r\n     * @dev Retriggers the sending of a message previously emitted by sendCrossChainMessage that has not yet been acknowledged\r\n     * with a receipt from the destination chain. This may be necessary in the unlikely event that less than the required\r\n     * threshold of stake weight successfully inserted the message in their messages DB at the time of the first submission.\r\n     * The message is checked to have already been previously submitted by comparing its message hash against those kept in\r\n     * state until a receipt is received for the message.\r\n     *\/\r\n    function retrySendCrossChainMessage(\r\n        TeleporterMessage calldata message\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Adds the additional fee amount to the amount to be paid to the relayer that delivers\r\n     * the given message ID to the destination chain.\r\n     *\r\n     * @dev The fee token address must be the same asset type as the fee asset specified in the original\r\n     * call to sendCrossChainMessage. Reverts if the message doesn't exist or there is already\r\n     * receipt of delivery of the message.\r\n     *\/\r\n    function addFeeAmount(\r\n        bytes32 messageID,\r\n        address feeTokenAddress,\r\n        uint256 additionalFeeAmount\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Receives a cross-chain message, and marks the `relayerRewardAddress` for fee reward for a successful delivery.\r\n     *\r\n     * @dev The message specified by `messageIndex` must be provided at that index in the access list storage slots of the transaction,\r\n     * and is verified in the precompile predicate.\r\n     *\/\r\n    function receiveCrossChainMessage(\r\n        uint32 messageIndex,\r\n        address relayerRewardAddress\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Retries the execution of a previously delivered message by verifying the payload matches\r\n     * the hash of the payload originally delivered, and calling the destination address again.\r\n     *\r\n     * @dev Intended to be used if message excution failed on initial delivery of the Teleporter message.\r\n     * For example, this may occur if the original required gas limit was not sufficient for the message\r\n     * execution, or if the destination address did not contain a contract, but a compatible contract\r\n     * was later deployed to that address. Messages are ensured to be successfully executed at most once.\r\n     *\/\r\n    function retryMessageExecution(\r\n        bytes32 sourceBlockchainID,\r\n        TeleporterMessage calldata message\r\n    ) external;\r\n\r\n    \/**\r\n     * @notice Sends the receipts for the given `messageIDs`.\r\n     *\r\n     * @dev Sends the specified message receipts in a new message (with an empty payload) back to the source chain.\r\n     * This is intended for use in sending receipts that have not been sent in a timely manner by the standard\r\n     * receipt delivery mechanism.\r\n     * @return The message ID of the newly sent message.\r\n     *\/\r\n    function sendSpecifiedReceipts(\r\n        bytes32 sourceBlockchainID,\r\n        bytes32[] calldata messageIDs,\r\n        TeleporterFeeInfo calldata feeInfo,\r\n        address[] calldata allowedRelayerAddresses\r\n    ) external returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Sends any fee amount rewards for the given fee asset out to the caller.\r\n     *\/\r\n    function redeemRelayerRewards(address feeTokenAddress) external;\r\n\r\n    \/**\r\n     * @notice Gets the hash of a given message stored in the EVM state, if the message exists.\r\n     * @return The message hash\r\n     *\/\r\n    function getMessageHash(bytes32 messageID) external view returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Checks whether or not the given message has been received by this chain.\r\n     * @return Boolean representing if the given message has been received.\r\n     *\/\r\n    function messageReceived(bytes32 messageID) external view returns (bool);\r\n\r\n    \/**\r\n     * @notice Returns the address the relayer reward should be sent to on the source chain\r\n     * for a given message, assuming that the message has already been delivered.\r\n     * @return The relayer reward address for the given message.\r\n     *\/\r\n    function getRelayerRewardAddress(\r\n        bytes32 messageID\r\n    ) external view returns (address);\r\n\r\n    \/**\r\n     * @notice Gets the current reward amount of a given fee asset that is redeemable by the given relayer.\r\n     * @return The amount of the fee asset redeemable by the specified relayer.\r\n     *\/\r\n    function checkRelayerRewardAmount(\r\n        address relayer,\r\n        address feeTokenAddress\r\n    ) external view returns (uint256);\r\n\r\n    \/**\r\n     * @notice Gets the fee token address and amount for a given sent message.\r\n     * @return The fee token address and fee amount for a the given sent message ID.\r\n     * If the message ID is not found, zero address and amount values are returned.\r\n     *\/\r\n    function getFeeInfo(\r\n        bytes32 messageID\r\n    ) external view returns (address, uint256);\r\n\r\n    \/**\r\n     * @notice Gets the message ID that would currently be used for the next message sent from the contract\r\n     * instance to the given destination blockchain.\r\n     *\r\n     * @dev This message ID may never be used in the event that the next call to sendCrossChainMessage in a\r\n     * transaction uses a different destination blockchain. The current value as returned by this function will\r\n     * change with each successful call to sendCrossChainMessage.\r\n     * @return The specified message ID.\r\n     *\/\r\n    function getNextMessageID(\r\n        bytes32 destinationBlockchainID\r\n    ) external view returns (bytes32);\r\n\r\n    \/**\r\n     * @notice Gets the number of receipts that are waiting to be sent to the given source chain ID.\r\n     * @return Size of the given queue.\r\n     *\/\r\n    function getReceiptQueueSize(\r\n        bytes32 sourceBlockchainID\r\n    ) external view returns (uint256);\r\n\r\n    \/**\r\n     * @notice Gets the receipt at the given index in the queue for the given source chain ID.\r\n     * @return The receipt requested.\r\n     *\/\r\n    function getReceiptAtIndex(\r\n        bytes32 sourceBlockchainID,\r\n        uint256 index\r\n    ) external view returns (TeleporterMessageReceipt memory);\r\n}\r\n\r\ninterface ITeleporterReceiver {\r\n    \/**\r\n     * @dev Called by TeleporterMessenger on the receiving chain.\r\n     *\r\n     * @param sourceBlockchainID is provided by the TeleporterMessenger contract.\r\n     * @param originSenderAddress is provided by the TeleporterMessenger contract.\r\n     * @param message is the TeleporterMessage payload set by the sender.\r\n     *\/\r\n    function receiveTeleporterMessage(\r\n        bytes32 sourceBlockchainID,\r\n        address originSenderAddress,\r\n        bytes calldata message\r\n    ) external;\r\n}\r\n\r\ncontract ReceiverMessage is ITeleporterReceiver {\r\n    ITeleporterMessenger public immutable messenger =\r\n        ITeleporterMessenger(0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf);\r\n\r\n    string public lastMessage;\r\n\r\n    function receiveTeleporterMessage(\r\n        bytes32,\r\n        address,\r\n        bytes calldata message\r\n    ) external {\r\n        \/\/ Only the Teleporter receiver can deliver a message.\r\n        require(\r\n            msg.sender == address(messenger),\r\n            \"ReceiverOnSubnet: unauthorized TeleporterMessenger\"\r\n        );\r\n\r\n        \/\/ Store the message.\r\n        lastMessage = abi.decode(message, (string));\r\n    }\r\n}\r\n"
}
export { contracts }